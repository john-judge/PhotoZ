//=============================================================================
// DapController.cpp
//=============================================================================
#include <iostream>
#include <stdlib.h>		// _gcvt()
#include <fstream>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <exception>

#include <FL/fl_ask.h>

#include "dapio32.h"
#include "DapController.h"
#include "UserInterface.h"
#include "DapChannel.h"
#include "Camera.h"
#include "DataArray.h"
#include "Definitions.h"


using namespace std;

/* hacky way of synchronizing things, but it seems to work and nothing better
 * was found
 */
#define CAM_INPUT_OFFSET 10

//=============================================================================
DapController::DapController()
{
	reset=new DapChannel(0,100);
	shutter=new DapChannel(0,1210);
	sti1=new DapChannel(300,1);
	sti2=new DapChannel(300,1);

	// Acquisition
	acquiOnset=float(50);

	// Number of points per trace
	program = 7;
	numPts=2000;
	intPts=1000.0 / (double) Camera::FREQ[program];

	// Flags
	stopFlag=0;
	scheduleFlag=0;
	scheduleRliFlag=0;

	// Ch1
	numPulses1=1;
	intPulses1=10;

	numBursts1=1;
	intBursts1=200;

	// Ch2
	numPulses2=1;
	intPulses2=10;

	numBursts2=1;
	intBursts2=200;

	// Set Duration
	setDuration();
}

//=============================================================================
DapController::~DapController()
{
	delete reset;
	delete shutter;
	delete sti1;
	delete sti2;
	releaseDAPs();
}

//=============================================================================
// Number of Points per Trace
//=============================================================================
void DapController::setNumPts(int p)
{
	numPts=p;
}

//=============================================================================
int DapController::getNumPts()
{
	return numPts;
}

//=============================================================================
// Acquisition Onset
//=============================================================================
void DapController::setAcquiOnset(float p)
{
	acquiOnset=p;
}

//=============================================================================
float DapController::getAcquiOnset()
{
	return acquiOnset;
}

//=============================================================================
// Acquisition Duration
//=============================================================================
float DapController::getAcquiDuration()
{
	return (float) (numPts*intPts);
}

//=============================================================================
void DapController::setCameraProgram(int p)
{
	program = p;
	intPts = 1000.0 / (float) Camera::FREQ[program];
}

//=============================================================================
int DapController::getCameraProgram()
{
	return program;
}

//=============================================================================
// Interval between Samples
//=============================================================================
void DapController::setIntPts(double p)
{
	intPts=p;
}

//=============================================================================
double DapController::getIntPts()
{
	return intPts;
}

//=============================================================================
// Acquisition
//=============================================================================
int DapController::acqui(short *memory, Camera &cam)
{
	int i;
	short *buf = new short[8*numPts];
	DapInputFlush(dap820Get);

	unsigned char *image;
	int width = cam.width();
	int height = cam.height();
	if (width != dataArray->raw_width() || height != dataArray->raw_height())
	{
		fl_alert("Camera not set up properly. Reselect camera size & frequency settings");
		cout << " line 158 width & height " << width << "   " << height << endl;
		return 0;
	}
	int num_diodes = dataArray->num_raw_diodes();
	
	// Start Acquisition
	cam.serial_write("@SEQ 0\@SEQ 1\r@TXC 1\r");
	Sleep(100);

	cam.start_images();
	DapLinePut(dap820Put,"START Send_Pipe_Output,Start_Output,Define_Input,Send_Data");

	int tos = 0;
	for (int ii = 0; ii < 7; ii++)	image = cam.wait_image();		// throw away first deadCount frames (usually 7) to clear camera saturation
																			// be sure to add deadCount  to COUNT in lines 327 and 399								
	for (i = 0; i < numPts; i++) {
		image = cam.wait_image();

		// Save the image to process later
		memcpy(memory + (num_diodes * i), image, width * height * sizeof(short));

		if (cam.num_timeouts() != tos) {
			printf("DapController line 180 timeout on %d\n", i);
			tos = cam.num_timeouts();
		}
		if (cam.num_timeouts() > 20) {
			cam.end_images();
			cam.serial_write("@TXC 0\r");
			return cam.num_timeouts();
		}
	}
	cam.end_images();
	cam.serial_write("@TXC 0\r");


	// Get Binary Data (digital outputs)
	int numBytes=DapBufferGet(dap820Get,8*numPts*sizeof(short),buf);
	for (i = 0; i < numPts; i++)
		memcpy(memory + (width * height) + (num_diodes*i), buf + (i*8), 8*sizeof(short));	// copy camera buffer into memory location set aside for raw data
	return 0;
}

//=============================================================================
void DapController::pseudoAcqui()
{
	DapLinePut(dap820Put,"START Send_Pipe_Output,Start_Output");
}

//=============================================================================
void DapController::resetDAPs()
{
	DapLinePut(dap820Put,"RESET");
}

void DapController::resetCamera()
{
	try {
		Camera cam;
		char command1[80];
		if (cam.open_channel()) {
			fl_alert("Failed to open the channel!\n");
		}
		//	if (getStopFlag() == 0) {
		int	sure = fl_ask("Are you sure you want to reset camera?");
		//	}
		if (sure == 1) {
			if (stop()) {
				cam.end_images();
				sprintf(command1, "c:\\EDT\\pdv\\initcam -u pdv0 -f c:\\EDT\\pdv\\camera_config\\Red-Shirt-80x80.cfg");
				system(command1);		//	command sequence from Chun B 4/22/2020

				int program = dc->getCameraProgram();
				short camGain = recControl->getAcquiGain();
				cam.program(program);
				cout  << " camera program  " << program << endl;
			}
		}
	}
	catch (exception& e) {
		cout << e.what() << '\n';
	}
}

//=============================================================================
int DapController::stop()
{
	stopFlag=1;

	setDAPs();
	resetDAPs();
	int status=DapConfig(dap820Put,"\\PhotoZ\\Stop v5.dap");

	if(status==0) {
		fl_alert("Failed to send Stop v5.dap to DAP!");
	}

	releaseDAPs();
	return status;
}

//=============================================================================
int DapController::sendFile2Dap(const char *fileName820)
{
	char fileName1[64]="\\PhotoZ\\";

	strcat_s(fileName1, 64,fileName820);

	if(!DapConfig(dap820Put,fileName1)) {
		char buf[64];
		DapLastErrorTextGet(buf,64);
		printf("DAP ERROR: %s\n", buf);
		return 0;
	}
	Sleep(500);		// wait .5 second for dap file to reach dap	 ?? needed
	return 1;
}

//=============================================================================
void DapController::createAcquiDapFile()
{
	fstream file;
	int i;

	//-------------------------------------------------------------------
	// Record-820 v5.dap

	file.open("\\PhotoZ\\Record-820 v5.dap",ios::out|ios::trunc);

	file<<";*****************************************\n";
	file<<";* Photoz5 Author:Payne Y. Chang  (c)2005*\n";
	file<<";*****************************************\n\n";

	file<<";*****************************************\n";
	file<<";* Fill Pipe_Output\n";
	file<<";*****************************************\n";
	fillPDOut(file,1);
	file<<"\n\n";

	file<<";*****************************************\n";
	file<<";* Start Output\n";
	file<<";*****************************************\n";
	file<<"ODEF Start_Output 3\n";
	file<<" OUTPUTWAIT 100\n";
	file<<" UPDATE BURST\n";
	file<<" SET OPIPE0 B0\n";
	file<<" SET OPIPE1 A0\n";
	file<<" SET OPIPE2 A1\n";
	file<<" TIME 333.33\n"; // 1000/3
	file<<"END\n\n";

	//-------------------------------------------------------------------
	// Input procedures

	file<<";*****************************************\n";
	file<<";* Define Input\n";
	file<<";*****************************************\n";
	file<<"IDEF Define_Input 8\n";
	file<<" vrange -10 10\n";

	// Set IPipe-S map
	for(i=0;i<8;i++)
		file << " set IPIPE" << i << " S" << i << '\n';

	// need to translate the offset count for 1000ms interval to the current interval.
	// full calculation is 1.0ms * CAM_INPUT_OFFSET / intPts
	// also need to do so for acquiOnset
	int start_offset = (int)((double) (CAM_INPUT_OFFSET + acquiOnset) / intPts);
	file << "\n TIME " << intPts * 125 << "\n";	// 1000/8
	//file << " HTrigger Oneshot\n";	// might be able to sync with outputs
	file << " COUNT " << 8 * (numPts+7 + start_offset) << "\n";			// added deadCount (usually = 7) to numPts to compensate for images skipped at beginning (line 171)
	file << "\nEND\n\n";

	file << ";*****************************************\n";
	file << ";* Send Data to PC\n";
	file << ";*****************************************\n";
	file << "PDEF Send_Data\n";
	file << " SKIP(IPIPE(0..7), " << 8*start_offset << ", 1, 0, $BINOUT)\n";
	file << "END\n\n";

	file<<";*****************************************\n";
	file<<";* Send Pipe_Output to Output Pipe\n";
	file<<";*****************************************\n";
	file<<"PDEF Send_Pipe_Output\n";
	file<<" COPY(Pipe_Output,OPIPE0)\n";
	file<<" COPY(PX,OPIPE1)\n";
	file<<" COPY(PX1,OPIPE2)\n";
	file<<"END\n\n";

	file << ";*****************************************\n";
	file << ";* END\n";
	file << ";*****************************************\n";

	file.close();

	//-------------------------------------------------------------------
	// PseudoRecord-820 v5.dap

	file.open("\\PhotoZ\\PseudoRecord-820 v5.dap",ios::out|ios::trunc);

	file<<";*****************************************\n";
	file<<";* Photoz5 Author:Payne Y. Chang  (c)2005*\n";
	file<<";*****************************************\n\n";

	file<<";*****************************************\n";
	file<<";* Fill Pipe_Output\n";
	file<<";*****************************************\n";
	fillPDOut(file,0);
	file<<"\n\n";

	file<<";*****************************************\n";
	file<<";* Send Pipe_Output to Output Pipe\n";
	file<<";*****************************************\n";
	file<<"PDEF Send_Pipe_Output\n";
	file<<" COPY(Pipe_Output,OPIPE0)\n";
	file<<"END\n\n";

	file<<";*****************************************\n";
	file<<";* Start Output\n";
	file<<";*****************************************\n";
	file<<"ODEF Start_Output 1\n";
	file<<" OUTPUTWAIT 10\n";
	file<<" UPDATE BURST\n";
	file<<" SET OPIPE0 B0\n";
	file<<" TIME 1000\n";
	file<<"END\n\n";

	//-------------------------------------------------------------------
	// Input procedures

	file<<";*****************************************\n";
	file<<";* Define Input\n";
	file<<";*****************************************\n";
	file<<"IDEF Define_Input 8\n";
	file<<" vrange -10 10\n";

	// Set IPipe-S map
	for(i=0;i<8;i++)
		file << " set IPIPE" << i << " S" << i << '\n';

	file << "\n TIME " << intPts * 125 << "\n";	// 1000/8
	//file << " HTrigger Oneshot\n";	// might be able to sync with outputs
	file << " COUNT " << 8 * (numPts+7) << "\n";		
	file << "\nEND\n\n";

	file << ";*****************************************\n";
	file << ";* Send Data to PC\n";
	file << ";*****************************************\n";
	file << "PDEF Send_Data\n";
	file << " MERGE(IPIPE(0..7),$BINOUT)\n";
	file << "END\n\n";

	file << ";*****************************************\n";
	file << ";* END\n";
	file << ";*****************************************\n";

	file.close();
	// END OF PSEUDORECORD
}

//=============================================================================
void DapController::setDuration()
{
	float time;
		
	time=acquiOnset+int(getAcquiDuration())+1;
	duration=time;

	time=reset->getOnset()+reset->getDuration();
	if(time>duration)
		duration=time;

	time=shutter->getOnset()+shutter->getDuration();
	if(time>duration)
		duration=time;

	time=sti1->getOnset()+sti1->getDuration()+(numPulses1-1)*intPulses1+(numBursts1-1)*intBursts1;
	if(time>duration)
		duration=time;

	time=sti2->getOnset()+sti2->getDuration()+(numPulses2-1)*intPulses2+(numBursts2-1)*intBursts2;
	if(time>duration)
		duration=time;

	duration++;

	if(duration>60000)
	{
		fl_alert("DC line 451 The total duration of the acquisition can not exceed 1 min! Please adjust DAP settings.");
		return;
	}
}

float DapController::getDuration() {
	return duration;
}

//=============================================================================
void DapController::fillPDOut(fstream & file,char realFlag)
{
	int i, j, k;
	float start,end;
	int *pipe = new int[60000];

	const int shutter_mask = (1 << 1);		// digital out 1
	const int sti1_mask = (1 << 2);			// digital out 2
	const int sti2_mask = (1 << 3);			// digital out 3
	const int cam_mask = (1 << 7);			// digital out 7

	//--------------------------------------------------------------
	// Reset the array
	memset(pipe, 0, sizeof(int) * 60000);

	//--------------------------------------------------------------
	// Reset : output[i]+=1
	/*start=reset->getOnset();
	end=start+reset->getDuration();

	for(i=start;i<end;i++)
	{
		pipe[i]+=1;
	}*/

	//--------------------------------------------------------------
	// Shutter
	if(realFlag) {
		start=shutter->getOnset();
		end=(start+shutter->getDuration());

		for(i=(int)start;i<end;i++)
			pipe[i] |= shutter_mask;
	}
	//--------------------------------------------------------------
	// Stimulator #1
	for(k=0;k<numBursts1;k++)
	{
		for(j=0;j<numPulses1;j++)
		{
			start=sti1->getOnset()+j*intPulses1+k*intBursts1;
			end=(start+sti1->getDuration());
			for(i=(int)start;i<end;i++)
				pipe[i] |= sti1_mask;
		}
	}
	//--------------------------------------------------------------
	// Stimulator #2
	for(k=0;k<numBursts2;k++)
	{
		for(j=0;j<numPulses2;j++)
		{
			start=sti2->getOnset()+j*intPulses2+k*intBursts2;
			end=(start+sti2->getDuration());
			for(i=(int)start;i<end;i++)
				pipe[i] |= sti2_mask;
		}
	}
	//--------------------------------------------------------------		
	// Camera Acquire
	//for (i = acquiOnset; i < acquiOnset + getAcquiDuration() + 0.5; i++)
	for (i = (int)acquiOnset; i < duration; i++)
		pipe[i] |= cam_mask;
	
	//--------------------------------------------------------------
	file << "PIPE Pipe_Output MAXSIZE=60000\n";
	for (i = 0; i < duration; i++) {
		if( (i%10) == 0)
			file << "\n Fill Pipe_Output";
		file << " " << pipe[i];
	}
	file << "\n Fill Pipe_Output 0 0 0 0 0 0 0 0 0 0";


	file << "\n\n\nPIPE PX MAXSIZE=60000";
	for (i = 0; i < duration; i++) {
		if((i%10) == 0)
			file << "\n FILL PX";
		if (pipe[i] & sti1_mask)
			file << " 32767";
		else
			file << " 0";
	}
	file << "\n Fill PX 0 0 0 0 0 0 0 0 0 0";

	file << "\n\n\nPIPE PX1 MAXSIZE=60000";
	for (i = 0; i < duration; i++) {
		if((i%10) == 0)
			file << "\n FILL PX1";
		if (pipe[i] & sti2_mask)
			file << " 32767";
		else
			file << " 0";
	}
	file << "\n Fill PX1 0 0 0 0 0 0 0 0 0 0";

	delete [] pipe;
}

//=============================================================================
void DapController::setStopFlag(char p)
{
	stopFlag=p;
}

//=============================================================================
char DapController::getStopFlag()
{
	return stopFlag;
}

//=============================================================================
int DapController::takeRli(short *memory, Camera &cam)
{
	int rliPts = 475;
	unsigned char *image;
	int width = cam.width();
	int height = cam.height();
	int array_diodes = dataArray->num_raw_array_diodes();
	if (width != dataArray->raw_width() || height != dataArray->raw_height())
	{
		fl_alert("Camera not set up properly. Reselect camera size & frequency settings");
		cout << " DapController line 577 - program  " << dc->getCameraProgram()<< endl;
		cout << "line 578 - width & height " << width << "   "  << height << endl;
		cout << "line 579 - raw values     " << dataArray->raw_width() << "   " << dataArray->raw_height() << endl;
		return 0;
	}
	DapLinePut(dap820Put,"STA Send_Pipe_Output,Start_Output");
	
	cam.start_images();
	for (int i = 0; i < rliPts; i++) 
	{
		image = cam.wait_image();
		// Save the image to process later
		memcpy(memory + (array_diodes * i), image, width * height * sizeof(short));
		if (cam.num_timeouts() > 10)
			return cam.num_timeouts();
	}
	cam.end_images();
	// overwrite the first point
	memcpy(memory, memory + array_diodes, width*height*sizeof(short));
	return 0;
}

//=============================================================================
void DapController::setNumPulses(int ch,int p)
{
	if(ch==1)
	{
		numPulses1=p;
	}
	else
	{
		numPulses2=p;
	}
}

//=============================================================================
void DapController::setNumBursts(int ch,int num)
{
	if(ch==1)
	{
		numBursts1=num;
	}
	else
	{
		numBursts2=num;
	}
}

//=============================================================================
int DapController::getNumBursts(int ch)
{
	int num;
	if(ch==1)
	{
		num=numBursts1;
	}
	else
	{
		num=numBursts2;
	}

	return num;
}

//=============================================================================
int DapController::getNumPulses(int ch)
{
	int num;
	if(ch==1)
	{
		return numPulses1;
	}
	else
	{
		return numPulses2;
	}

	return num;
}

//=============================================================================
void DapController::setIntBursts(int ch,int p)
{
	if(ch==1)
	{
		intBursts1=p;
	}
	else
	{
		intBursts2=p;
	}
}

//=============================================================================
void DapController::setIntPulses(int ch,int p)
{
	if(ch==1)
	{
		intPulses1=p;
	}
	else
	{
		intPulses2=p;
	}
}

//=============================================================================
int DapController::getIntBursts(int ch)
{
	int num;

	if(ch==1)
	{
		num=intBursts1;
	}
	else
	{
		num=intBursts2;
	}

	return num;
}

//=============================================================================
int DapController::getIntPulses(int ch)
{
	int num;

	if(ch==1)
	{
		num=intPulses1;
	}
	else
	{
		num=intPulses2;
	}

	return num;
}

//=============================================================================
void DapController::setScheduleFlag(char p)
{
	scheduleFlag=p;
}

//=============================================================================
void DapController::setScheduleRliFlag(char p)
{
	scheduleRliFlag=p;
}

//=============================================================================
char DapController::getScheduleFlag()
{
	return scheduleFlag;
}

//=============================================================================
char DapController::getScheduleRliFlag()
{
	return scheduleRliFlag;
}

//=============================================================================
int DapController::setDAPs()
{
	dap820Put=DapHandleOpen("\\\\.\\Dap0\\$SysIn", DAPOPEN_WRITE);
	if (!dap820Put) {
		char buf[64];
		DapLastErrorTextGet(buf,64);
		printf("ERROR: setDAPs could not open dap820Put: %s\n", buf);
	}
	dap820Get=DapHandleOpen("\\\\.\\Dap0\\$BinOut", DAPOPEN_READ);
	if (!dap820Get) {
		char buf[64];
		DapLastErrorTextGet(buf,64);
		printf("ERROR: setDAPs could not open dap820Get: %s\n", buf);
	}
	return 0;
}

//=============================================================================
void DapController::releaseDAPs()
{
	DapHandleClose(dap820Get);
	DapHandleClose(dap820Put);
}

//=============================================================================
